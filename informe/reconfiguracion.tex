\section{Reconfiguración de rutas}

\subsection{Descripción del problema}
Este problema plantea otra provincia de Optilandia, cuyas ciudades están conectadas por rutas pero con ciertos problemas: algunas ciudades no están conectadas y otras poseen varias maneras para viajar entre ellas. Para solucionarlo, el gobierno hará obras en las rutas de modo que haya una y sólo una forma de llegar desde cualquier ciudad a otra, construyendo nuevas rutas o destruyendo rutas existentes. 
\\
\par
Nos piden un algoritmo que, dadas las rutas y los costos de construcción y destrucción, nos diga que rutas hay que destruir y construir para satisfacer el problema de forma que gastemos lo menor posible. Como requisito, la complejidad de este algoritmo no puede ser peor que \textbf{O($n^2log(n)$)}, donde n es la cantidad de ciudades de la provincia.
\\
\par
\textbf{Agregar ejemplos}
\\
\par
\subsection{Desarrollo}
Como es usual, podemos representar a las ciudades como nodos de un grafo y a las rutas como los ejes, como no se especifica si las rutas son de una o dos manos vamos a asumir que las rutas son bidireccionales. Pero en este caso tenemos rutas existentes que se pueden destruir y rutas que se pueden crear, vamos a dividir estos ejes en dos conjuntos $C$ y $D$, el primero va a tener los ejes con los costos de construcción de rutas y el segundo va a tener los costos de destrucción, los costos de las rutas se representan como el peso del eje que representa esa ruta. Notemos que $C \cup D$ contiene las aristas de un grafo completo. %ejes
\\
\par
Una vez encontrada la solución, vamos a tener rutas que quedaron intactas y rutas que se construyeron, entonces vamos a llamar $RC$ un subconjunto de aristas de $C$ que contiene las rutas que deben construirse para lograr la solución óptima y $RD$ un subconjunto de $D$ que contiene las rutas que hay que mantener, podemos notar que $D - RD$ es el conjunto de rutas que hay que destruir, y que $RD \cup RC$ nos da como resultado la representación de la provincia una vez terminado el plan, llamaremos solución al conjunto de ejes $R$. %ejes
\\
\par
El objetivo del algoritmo es que todas las ciudades se conecten solo de una manera, lo que en grafos sería que existe exactamente un camino simple entre todo par de
nodos y cómo sabemos, si pasa esto, el grafo es un árbol. Entonces el queremos llegar a que $R$ sea el conjunto de aristas de un árbol generador del grafo de entrada. %ejes
\\
\par
Lo primero que podemos notar, es que, si $RD$ no es un bosque, tiene ciclos. Si tiene ciclos, no hay manera de que agregando aristas se obtenga un árbol. Como ya dijimos que $R$ tiene que ser un árbol, $RD$ tiene que ser un bosque. %TODO RD no puede ser un bosque porque son aristas nada mas %grafo
\\
\par
Como $R$ tiene que ser árbol, y $RD$ bosque, $RC$ tiene que tener ejes que unen las componentes conexas de $RD$, sin formar ciclos.  Además queremos que el costo de la suma de las aristas que se agreguen sea mínimo. El algoritmo de Kruskal nos va a resolver esto, ya que en la invariante mantiene un bosque y agrega golosamente aristas que conectan componentes hasta llegar a un árbol. Nos vamos a aprovechar de esto y vamos aplicar Kruskal partiendo del bosque conformado por las aristas de $RD$. Como es bosque no rompe la invariante y en cada paso conecta a una de las componentes de $RD$ con una arista perteneciente a $C$ y agregando dicha arista a $RC$. %grafo
\\
\par
Entonces sabemos buscar un $RC$ óptimo dado un $RD$, ahora tenemos que buscar un $RD$ tal que los costos resultantes sean mínimos. Para esto se nos ocurrió que $RD$ tiene que contener las aristas de un “Bosque Generador Máximo de $D$”, con bosque generador máximo(BGM) de $D$ nos referimos a un subgrafo de $D$ tal que para cada componente conexa $D_i$ de $D$, existe una componente conexa $BGM_i$ perteneciente al BGM de $D$ tal que $BGM_i$ es árbol generador máximo de $D_i$. 
\\
\par
Veamos por qué el BGM es el bosque óptimo que tenemos para asignar a $RD$. Tenemos a $D$ con componentes conexas $D_1 , D_2 , … , D_k$, al sacar un eje cualquiera, digamos que este eje pertenecía a $D_i$, si este eje estaba en un ciclo la componente seguirá teniendo los mismos nodos, pero sino, entonces dividiremos a $D_i$ en dos componentes conexas, llamemoslas $D_i1$ y $D_i2$ y veamos que esta división de componentes encarece la construcción de $R$ dado este $RD$. 
\\
\par
Llamemos a $RD'$ a un bosque subgrafo de $D$ tal que las componentes conexas tienen los mismos nodos que las componentes conexas de $D$ y llamemos $RD''$ a otro tal que le quitamos un eje $e$, de la componente conexa $D_i$ dividiéndola en $D_i1$ y $D_i2$, a lo que queremos llegar es que si aplicamos Kruskal para conseguir el $RC$ óptimo, si le pasamos $RD’’$ el $RC$ resultante tendrá los mismos ejes y uno más, que si le hubiésemos pasado $RD’$ y como estamos diciendo, el costo total de construcción sería más caro y el de destrucción también porque estamos quitando un eje y eso nos cuesta.
\\
\par
Cuando aplicamos el Kruskal para conseguir el $RC$, estamos uniendo componentes conexas, como $RD’’$ tiene una componente más, el $RC$ que parte de $RD’’$ tendrá $k$ ejes y el que parte de $RD’$ tendrá $k-1$ y que estos $k-1$ están todos incluidos en los de $RD’’$. El algoritmo de Kruskal va manteniendo las componentes conexas y evita que se agreguen ejes que unen nodos dentro de una misma componente para que no se formen ciclos, osea que si unimos dos componentes tenemos una nueva componente que contiene a los dos, cuando aplicamos el algoritmo dado $RD’’$ en algún momento a tener una componente conexa que contenga a $D_i1$  y otra que contenga a $D_i2$, llamemoslas $A$ y $B$ respectivamente, y el algoritmo elegirá un eje que nos combine las componentes, la intuición está en que los ejes que escogió antes y lo que escoge después son los mismos que en el Kruskal de $RD’$. Notemos que hasta que el algoritmo escoja un eje que une $A$ y $B$, todos estos ejes son también válidos para cuando lo aplicamos en $RD’$, de hecho va a escoger estos ya que son los mejores posibles en ambos casos, el problema es que en $RD’$ existe el eje $e$, el que quitamos en $RD’’$ que une $D_i1$ y $D_i2$ osea que vamos ya a tener combinados $A$ y $B$ en una componente sin este costo adicional que tiene al agregar el eje en $RD’’$ para unir $A$ y $B$, después el estado de componentes conexas que igual y el algoritmo avanzara igual en ambos casos.
\\
\par
Con esto vimos que si dividimos una componente del bosque nos empeora el costo, también podemos decir que empeora no sólo cuando dividimos una sola componente si no cuando hacemos múltiples divisiones, que es lo mismo que ir haciendo una por una, por lo que por cada división va a empeorar. Gracias a esto podemos apreciar que no tenemos que dividir las componentes conexas, o lo que es lo mismo tener un bosque generador, ahora nos queda ver que el bosque generador máximo es el óptimo. Definimos al costo de $BG$ bosque generador de $D$  como la suma de los pesos de los ejes pertenecientes a $D - BG$ y buscamos que $RD$ sea el bosque generador de costo mínimo. Si $RD$ fuera distinto del BGM de $D$, significaría que el costo de $RD$ es menor que el costo del BGM de $D$ lo cual es absurdo porque el BGM de $D$ es el bosque generador obtenido a partir de la destrucción de las rutas más baratas. Entonces $RD$ tiene que ser el BGM de $D$.
\\
\par
Resumiendo, los pasos a seguir son:
\begin{enumerate}
\item Construir dado los datos de entrada crear $D$ y $C$
\item Dado $D$ construimos $RD$ tal que cada componente
\item Conseguir el $RC$ óptimo dado $RD$
\item Calcular los el costo de destrucción y construcción
\end{enumerate}
Para construir $RD$ decidimos usar Kruskal ya que también lo vamos a usar para conseguir $RC$. Para este caso tuvimos que modificar un poco el algoritmo de Kruskal, dado que, primero necesitamos que priorice los ejes pesados y además ya que $D$ puede ser que no sea conexo, necesitamos pare cuando no pueda agregar ejes ya que si no es conexo hay componentes que no podemos unir, que las tendremos que unir construyendo. En nuestro caso usamos la implementación de Kruskal que usa internamente Disjoint Set, esta estructura la vamos a pasar por referencia porque la vamos a usar más adelante.
Después de aplicarle Kruskal a $D$ tenemos el Disjoint Set con el estado de $RD$, ahora como ya dijimos, aplicamos Kruskal con el Disjoint Set de $RD$ pero con los ejes de $C$, como resultante vamos a obtener los ejes de $R$. Finalizando, ya tenemos los ejes que hay no queremos destruir y los ejes que vamos a construir, nos falta calcular el coste total del plan, para eso vamos a buscar sobre los ejes que nos dan como datos, y ver sus respectivos pesos.


\subsection{Cota temporal}

\subsection{Experimentacion}

\pagebreak