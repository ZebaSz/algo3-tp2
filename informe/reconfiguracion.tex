\section{Reconfiguración de rutas}

\subsection{Descripción del problema}
Este problema plantea otra provincia de Optilandia, cuyas ciudades están conectadas por rutas pero con ciertos problemas: algunas ciudades no están conectadas y otras poseen varias maneras para viajar entre ellas. Para solucionarlo, el gobierno hará obras en las rutas de modo que haya una y sólo una forma de llegar desde cualquier ciudad a otra, construyendo nuevas rutas o destruyendo rutas existentes. 
\\
\par
Nos piden un algoritmo que, dadas las rutas y los costos de construcción y destrucción, nos diga que rutas hay que destruir y construir para satisfacer el problema de forma que gastemos lo menor posible. Como requisito, la complejidad de este algoritmo no puede ser peor que \textbf{O($n^2log(n)$)}, donde n es la cantidad de ciudades de la provincia.
\\
\par
Veamos un ejemplo del problema. Supongamos que tuvieramos 6 ciudades, con las siguientes rutas iniciales y con los siguientes costos de destrucción expresados en pesos:
\begin{itemize}
\item Ruta de 1 a 2. Costo de destrucción: 100 pesos.
\item Ruta de 1 a 4. Costo de destrucción: 230 pesos.
\item Ruta de 1 a 6. Costo de destrucción: 65 pesos.
\item Ruta de 2 a 4. Costo de destrucción: 190 pesos.
\item Ruta de 2 a 6. Costo de destrucción: 300 pesos.
\item Ruta de 3 a 5. Costo de destrucción: 150 pesos.
\end{itemize}

Por otro lado, tendríamos las siguientes rutas a disposición para construir, con el siguiente costo:

\begin{itemize}
\item Ruta de 1 a 3. Costo de construcción: 150 pesos.
\item Ruta de 1 a 5. Costo de construcción: 130 pesos.
\item Ruta de 2 a 3. Costo de construcción: 190 pesos.
\item Ruta de 2 a 5. Costo de construcción: 50 pesos.
\item Ruta de 2 a 6. Costo de construcción: 80 pesos.
\item Ruta de 3 a 4. Costo de construcción: 300 pesos.
\item Ruta de 3 a 6. Costo de construcción: 170 pesos.
\item Ruta de 4 a 5. Costo de construcción: 200 pesos.
\item Ruta de 4 a 6. Costo de construcción: 150 pesos.
\item Ruta de 5 a 6. Costo de construcción: 140 pesos.
\end{itemize}

Por lo tanto, la solución más eficiente para dejar un único camino entre todas las ciudades sería:

\begin{enumerate}
\item Destruir la ruta de 1 a 6, a un costo de 65 pesos
\item Destruir la ruta de 1 a 2, a un costo de 100 pesos
\item Construir la ruta de 2 a 5, a un costo de 50 pesos
\end{enumerate}

Lo cual nos daría un costo total de 215 pesos, siendo esta la forma más barata de dejar todas las ciudades conectadas.
\\
\subsection{Desarrollo}
Como es usual, podemos representar a las ciudades como nodos de un grafo y a las rutas como los ejes, como no se especifica si las rutas son de una o dos manos vamos a asumir que las rutas son bidireccionales. Pero en este caso tenemos rutas existentes que se pueden destruir y rutas que se pueden crear, vamos a dividir estos ejes en dos conjuntos $C$ y $D$, el primero va a tener los ejes con los costos de construcción de rutas y el segundo va a tener los costos de destrucción, los costos de las rutas se representan como el peso del eje que representa esa ruta. Notemos que $C \cup D$ contiene las aristas de un grafo completo. %ejes
\\
\par
Una vez encontrada la solución, vamos a tener rutas que quedaron intactas y rutas que se construyeron, entonces vamos a llamar $RC$ un subconjunto de aristas de $C$ que contiene las rutas que deben construirse para lograr la solución óptima y $RD$ un subconjunto de $D$ que contiene las rutas que hay que mantener, podemos notar que $D - RD$ es el conjunto de rutas que hay que destruir, y que $RD \cup RC$ nos da como resultado la representación de la provincia una vez terminado el plan, llamaremos solución al conjunto de ejes $R$. %ejes
\\
\par
El objetivo del algoritmo es que todas las ciudades se conecten solo de una manera, lo que en grafos sería que existe exactamente un camino simple entre todo par de
nodos y cómo sabemos, si pasa esto, el grafo es un árbol. Entonces el queremos llegar a que $R$ sea el conjunto de aristas de un árbol generador del grafo de entrada. %ejes
\\
\par
Lo primero que podemos notar, es que, si $RD$ no es un bosque, tiene ciclos. Si tiene ciclos, no hay manera de que agregando aristas se obtenga un árbol. Como ya dijimos que $R$ tiene que ser un árbol, $RD$ tiene que ser un bosque. %TODO RD no puede ser un bosque porque son aristas nada mas %grafo
\\
\par
Como $R$ tiene que ser árbol, y $RD$ bosque, $RC$ tiene que tener ejes que unen las componentes conexas de $RD$, sin formar ciclos.  Además queremos que el costo de la suma de las aristas que se agreguen sea mínimo. El algoritmo de Kruskal nos va a resolver esto, ya que en la invariante mantiene un bosque y agrega golosamente aristas que conectan componentes hasta llegar a un árbol. Nos vamos a aprovechar de esto y vamos aplicar Kruskal partiendo del bosque conformado por las aristas de $RD$. Como es bosque no rompe la invariante y en cada paso conecta a una de las componentes de $RD$ con una arista perteneciente a $C$ y agregando dicha arista a $RC$. %grafo
\\
\par
Entonces sabemos buscar un $RC$ óptimo dado un $RD$, ahora tenemos que buscar un $RD$ tal que los costos resultantes sean mínimos. Para esto se nos ocurrió que $RD$ tiene que contener las aristas de un “Bosque Generador Máximo de $D$”, con bosque generador máximo(BGM) de $D$ nos referimos a un subgrafo de $D$ tal que para cada componente conexa $D_i$ de $D$, existe una componente conexa $BGM_i$ perteneciente al BGM de $D$ tal que $BGM_i$ es árbol generador máximo de $D_i$. 
\\
\par
Veamos por qué el BGM es el bosque óptimo que tenemos para asignar a $RD$. Tenemos a $D$ con componentes conexas $D_1 , D_2 , … , D_k$, al sacar un eje cualquiera, digamos que este eje pertenecía a $D_i$, si este eje estaba en un ciclo la componente seguirá teniendo los mismos nodos, pero sino, entonces dividiremos a $D_i$ en dos componentes conexas, llamemoslas $D_i1$ y $D_i2$ y veamos que esta división de componentes encarece la construcción de $R$ dado este $RD$. 
\\
\par
Llamemos a $RD^{\prime}$ a un bosque subgrafo de $D$ tal que las componentes conexas tienen los mismos nodos que las componentes conexas de $D$ y llamemos $RD^{\prime\prime}$ a otro tal que le quitamos un eje $e$, de la componente conexa $D_i$ dividiéndola en $D_i1$ y $D_i2$, a lo que queremos llegar es que si aplicamos Kruskal para conseguir el $RC$ óptimo, si le pasamos $RD^{\prime\prime}$ el $RC$ resultante tendrá los mismos ejes y uno más, que si le hubiésemos pasado $RD^{\prime}$ y como estamos diciendo, el costo total de construcción sería más caro y el de destrucción también porque estamos quitando un eje y eso nos cuesta.
\\
\par
Cuando aplicamos el Kruskal para conseguir el $RC$, estamos uniendo componentes conexas, como $RD^{\prime\prime}$ tiene una componente más, el $RC$ que parte de $RD^{\prime\prime}$ tendrá $k$ ejes y el que parte de $RD^{\prime}$ tendrá $k-1$ y que estos $k-1$ están todos incluidos en los de $RD^{\prime\prime}$. El algoritmo de Kruskal va manteniendo las componentes conexas y evita que se agreguen ejes que unen nodos dentro de una misma componente para que no se formen ciclos, osea que si unimos dos componentes tenemos una nueva componente que contiene a los dos, cuando aplicamos el algoritmo dado $RD^{\prime\prime}$ en algún momento a tener una componente conexa que contenga a $D_i1$  y otra que contenga a $D_i2$, llamemoslas $A$ y $B$ respectivamente, y el algoritmo elegirá un eje que nos combine las componentes, la intuición está en que los ejes que escogió antes y lo que escoge después son los mismos que en el Kruskal de $RD^{\prime}$. Notemos que hasta que el algoritmo escoja un eje que une $A$ y $B$, todos estos ejes son también válidos para cuando lo aplicamos en $RD^{\prime}$, de hecho va a escoger estos ya que son los mejores posibles en ambos casos, el problema es que en $RD^{\prime}$ existe el eje $e$, el que quitamos en $RD^{\prime\prime}$ que une $D_i1$ y $D_i2$ osea que vamos ya a tener combinados $A$ y $B$ en una componente sin este costo adicional que tiene al agregar el eje en $RD^{\prime\prime}$ para unir $A$ y $B$, después el estado de componentes conexas que igual y el algoritmo avanzara igual en ambos casos.
\\
\par
Con esto vimos que si dividimos una componente del bosque nos empeora el costo, también podemos decir que empeora no sólo cuando dividimos una sola componente si no cuando hacemos múltiples divisiones, que es lo mismo que ir haciendo una por una, por lo que por cada división va a empeorar. Gracias a esto podemos apreciar que no tenemos que dividir las componentes conexas, o lo que es lo mismo tener un bosque generador, ahora nos queda ver que el bosque generador máximo es el óptimo. Definimos al costo de $BG$ bosque generador de $D$  como la suma de los pesos de los ejes pertenecientes a $D - BG$ y buscamos que $RD$ sea el bosque generador de costo mínimo. Si $RD$ fuera distinto del BGM de $D$, significaría que el costo de $RD$ es menor que el costo del BGM de $D$ lo cual es absurdo porque el BGM de $D$ es el bosque generador obtenido a partir de la destrucción de las rutas más baratas. Entonces $RD$ tiene que ser el BGM de $D$. Y para conseguirlo vamos a usar Kruskal tambien y vamos a modificarlo para que pare cuando no pueda agregar mas ejes, y este nos dara como resultado el BGM.
\\
\par
Resumiendo, los pasos a seguir son:
\begin{enumerate}
\item Obtener los datos de entrada para crear $D$ y $C$
\item Con $D$ construimos $RD$ (BGM) 
\item Conseguir el $RC$ óptimo dado $RD$
\item Calcular los costos de destrucción y construcción
\end{enumerate}

A medida que nos informan las rutas, vamos agregando las rutas en dos listas de ejes, dependiendo si es una existente o si es de construcción. Una vez creadas las listas, corremos Kruskal (en este caso prioriza los ejes caros) de sobre los ejes de destrucción, implementamos Kruskal con Disjoint Set, y para reusar el Disjoint Set en la parte de construcción, este recibe por referencia la estructura. Cuando finaliza el Kruskal recorremos los ejes que nos devuelve y nos fijamos los costos, para después restarle al costo total del grafo $D$ (Ya que eso nos da el costo total de los ejes que destruimos). Después de obtener $RD$, corremos Kruskal de vuelta pero esta vez para buscar el árbol generador mínimo, para esto le tenemos que pasar el Disjoint Set que nos había quedado del anterior Kruskal  y los ejes de las rutas que se pueden construir. Una vez más esto nos devuelve los ejes que vamos a utilizar, calculamos su costo, lo sumamos con el anterior y ya tenemos toda la respuesta.

\subsection{Cota temporal}

Para tener una cota de la complejidad temporal de nuestro algoritmo, debemos enfatizar en la complejidad de la implementación de Kruskal, ya que es el corazón de la resolución del problema. El algoritmo básicamente lo que hace es :
\begin{enumerate}
	\item Creamos un conjunto de ejes A vacío que va terminar siendo nuestra solución
\item Crear una estructura B que contenga las componentes conexas de un bosque, inicializada con los nodos del grafo como nodos separados.
\item Creamos un conjunto C con las aristas del grafo.
\item Mientras C no sea vacío.
\begin{enumerate}
\item Sacamos la arista de menor o mayor peso (según los parámetros del algoritmo) de C
\item Si la arista conecta dos componentes diferentes, se la añade a A y se combinan estas componentes de B.
\item Caso contrario, descartamos esta arista
\end{enumerate}
\end{enumerate}
 
Primero ordenamos los ejes, usamos el sort de la Standard Library así que en el peor de los casos este paso nos costará $O(mlog(m))$ o lo que es lo mismo $O(mlog(n))$. Después tenemos que iterar las aristas, esta parte está fuertemente atada a la estructura de datos que se usa internamente para el bosque, nosotros usamos un Disjoint Set (Conjuntos Disjuntos) y lo implementamos con un par de heurísticas \textbf{Union by Rank} y \textbf{Path Compression}, con esto podemos probar que una secuencia de $k$ operaciones de la estructura corren en tiempo $O(k\alpha (n))$ donde $\alpha$ es la inversa de la función de Ackermann, por lo que la iteración de las aristas nos da una complejidad en peor caso de $O(m\alpha (n))$. Lamentablemente esto se ve mitigado por el ordenamiento de los ejes, así que el algoritmo de Kruskal, en nuestra implementación, tiene una complejidad temporal de $O(mlog(n))$ en peor caso. 
 
En la resolución del problema corremos Kruskal dos veces, para el grafo original y para su complemento, como en el peor de los casos tenemos $n^2$ aristas, estas dos corridas tienen una complejidad de $O(n^2log(n))$. Por último tenemos que recolectar el peso de las aristas resultantes, que son $n-1$ porque es un árbol y esto lo podemos solucionar en tiempo lineal, osea que la complejidad $O(n^2log(n))$ se ajusta a lo pedido.


\subsection{Experimentacion}

Al experimentar con este problema, nos esperabamos encontrar que el problema solo estuviese definido por la cantidad de ciudades, ya que la cantidad de rutas dependía de la misma (si unimos las rutas existentes con las potenciales, obtenemos un grafo completo). Supusimos que la proporción de rutas existentes y a construir no causaría ninguna diferencia de complejidad, ya que el algoritmo requiere que se recorran todas y la suma siempre da igual para un n dado.

\begin{center}
	\includegraphics[scale=0.5]{imagenes/ej3-1.png}
	\includegraphics[scale=0.5]{imagenes/ej3-2.png}
\end{center}

Efectivamente, la experimentación confirmó que el algorítmo no se ve afectado por la proporción entre las rutas ya existentes y aquellas a construir. Por otro lado, la cantidad de ciudades tiene un impacto aproximadamente cuadrático. Esto es de esperarse, ya que la complejidad efectiva es $O(n^2log(n))$, pero el aspecto cuadrático es más visible que el logarítmo.

\pagebreak