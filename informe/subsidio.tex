\section{Subsidiando el transporte}

\subsection{Descripción del problema}
En este problema, observamos la provincia de Optilandia, cuyas ciudades estan conectadas por rutas de una sola dirección, donde no necesariamente se puede llegar de una ciudad a todas las demás. Sin embargo, sabemos que desde cualquier ciudad se puede llegar, al menos, a otra ciudad. Cada una de estas rutas tiene una cabina de peaje y, por ende, recorrer cada una de ellas tiene un costo. Sin embargo, por decisiones gubernamentales, cada uno de estos peajes se vio reducido por un costo fijo c (si antes la ruta A valía A1, y la ruta B valía B1, ahora valen A1 - c y B1 - c respectivamente), pudiendo generar que una ruta no solo no le cobre a sus usuarios, sino que acabe dándole dinero.
\\
\par
Si bien esto no es un problema para el gobierno, siempre y cuando se evite que un usuario pueda irse desde una ciudad, hacer un recorrido y volver a la misma habiendo ganado plata. Por lo tanto, como el gobierno busca maximizar el subsidio otorgado, debemos buscar el valor c que permita otorgar el mayor subsidio por peaje sin que exista la posibilidad de que un usuario le saque plata al Estado. La complejidad del algoritmo debe ser no peor que O(nm.log(c)), donde n es la cantidad de ciudades, m es la cantidad de rutas y c es el costo del máximo peaje
\\
\par

\textbf{Agregar ejemplos}
\\
\par
\subsection{Desarrollo}
Dado este problema, podemos modelarlo utilizando digrafos. Así, cada ciudad se representaría con un nodo, y cada una de las rutas que conecta dos ciudades, con una arista dirigida. Consideraremos que un recorrido abusivo es representado por un ciclo negativo en el digrafo.
\\
\par
El algoritmo propuesto para encontrar ciclos negativos es el algoritmo de Bellman-Ford. Es un algoritmo que encuentra caminos minimos entre un nodo y el resto de los nodos. Su complejidad es peor que la del algoritmo de Dijkstra, pero nos permite trabajar con aristas negativas y también identificar ciclos negativos. 
\\
\par
\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Bellman-Ford}{\In{n}{int}, \In{m}{int}, \In{edges}{(int, int, int)}, \In{source}{int}, \Inout{distance}{int[]}}{bool}}
		
		int i, j
		
		\For{i in [0..n)}
		{
			distance[i] $\leftarrow$ INF
		}
		
		distance[source] $\leftarrow$ 0
		
		\For{i in [0..n)}
		{
			\For{(u,v,w) in edges}
			{
				\If{distance[u] + w $<$ distance[v]}
				{
					distance[v] $\leftarrow$ distance[u] + w
				}
				
			}
		}

		res $\leftarrow$ false
		
		\For{(u,v,w) in edges}
			{
				\If{distance[u] + w $<$ distance[v]}
				{
					res $\leftarrow$ true
				}
				
			}

	\end{algorithm}

\\
\par

\subsection{Cota temporal}

\subsection{Experimentacion}

\pagebreak



 



